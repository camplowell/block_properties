import argparse
import json
from pathlib import Path
import sys
from typing import Dict, FrozenSet, List

from core.block import BlockCollection
from core.tag import TagLibrary
from evaluation.evaluator import evaluate
from mixins.register import register_all_mixins

DATA_DIR = './data'
library = TagLibrary(DATA_DIR)
register_all_mixins(library)
LINE_UP = '\033[1A'
LINE_CLEAR = '\x1b[2K'

def swizzle(a:BlockCollection, b:BlockCollection):
	both = a.intersection(b)
	return (a - b, b - a, both)

def bake_masks(states:Dict[str, str]):
	result:Dict[FrozenSet[str], BlockCollection] = dict()
	print('Evaluating flags...')
	queue = [(frozenset([key]), evaluate(expr, library)) for (key, expr) in states.items()]
	num_keys = len(queue)
	i = 1
	print('Baking masks...')
	while queue:
		key, blocks = queue.pop()
		if len(key) == 1:
			if i > 1:
				print(LINE_UP, end=LINE_CLEAR)
			print(f'    {list(key)[0]} ({i}/{num_keys})')
			i += 1
		for key_v in list(result.keys()):
			both_key = key_v.union(key)
			if both_key == key or both_key == key_v:
				continue
			result[key_v], blocks, both = swizzle(result[key_v], blocks)
			if both:
				queue.append((key_v.union(key), both))
		if blocks:
			result[key] = blocks
	print(LINE_UP, end=LINE_CLEAR)
	return {k:v for (k,v) in result.items() if len(v)}

def _set_key(states:List[str]):
	def key(a:FrozenSet[str]):
		return tuple(sorted([states.index(x) for x in a]))

	return key

def generate_properties_file(path:Path, masks:Dict[FrozenSet[str], BlockCollection], config:dict):
	states = list(config['flags'].keys())
	start_index = config['start_index'] or 1
	
	lines = [
		"## This file has been automatically generated. Please do not modify manually.",
		"## Generated by Lowell's BlockProperties Utility v1.0 - https://github.com/camplowell/block_properties",
		""
	]
	i = start_index
	mapping:Dict[int, FrozenSet[str]] = dict()
	for mask in sorted(masks.keys(), key=_set_key(states)):
		blocks = masks[mask]
		lines.append(f'\n# {", ".join(sorted(mask, key=lambda x: states.index(x)))}')
		lines.append(f'block.{i} = {repr(blocks)}')
		mapping[i] = mask
		i += 1
	
	with path.open('w') as writer:
		writer.write('\n'.join(lines))
	
	return mapping

def generate_decoder_file(path:Path, masks:Dict[FrozenSet[str], BlockCollection], config:dict, mapping:Dict[int, FrozenSet[str]]):
	states = list(config['flags'].keys())
	start_index = config['start_index'] or 1
	decoder_pragma = config['decoder_pragma'] or 'BLOCK_PROPERTIES_DECODER'

	lines = [
		f'#if !defined({decoder_pragma})',
		f'#define {decoder_pragma}',
		"",
		"// This file has been automatically generated. Please do not modify manually.",
		"// Generated by Lowell's BlockProperties Utility v1.0 - https://github.com/camplowell/block_properties",
		""
	]

	for state in states:
		valid_ids = ["id == {}".format(i) for (i, mask) in mapping.items() if state in mask]
		lines.append(f'\nbool {state}(int id) {{')
		lines.append(f'    return {" || ".join(valid_ids) if valid_ids else "false"};')
		lines.append( "}")

	lines.append("\n#endif // EOF")
	
	with path.open('w') as writer:
		writer.write('\n'.join(lines))
	
def export(config:Path):
	config = Path(config)
	with config.open() as config_stream:
		config_json = json.load(config_stream)
	print(f'Loaded configuration at {config}.')
	config_dir = config.parent

	props_path = config_dir.joinpath(config_json['properties_file'])
	decoder_path = config_dir.joinpath(config_json['decoder_file'])
	
	flags = dict(config_json['flags'])
	states = list(flags.keys())
	print(f'Found {len(states)} flags.')
	masks = bake_masks(flags)
	print(f'Outputting to disk...')
	mapping = generate_properties_file(props_path, masks, config_json)
	generate_decoder_file(decoder_path, masks, config_json, mapping)
	print('Done!')

arg_parser = argparse.ArgumentParser(
	prog="exporter",
	description="Assemble tags into block.properties files",
	epilog='Nested tags are written as "parent/child" and enum tags are written as "tag:value"'
)

arg_parser.add_argument('config', type=str, nargs='+')

if __name__ == "__main__":
	args = arg_parser.parse_args()
	args.config = ' '.join(args.config)
	export(**args.__dict__)